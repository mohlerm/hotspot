While this thesis provides a first look on implementing a system to reuse profiles from previous JVM runs, it leaves room for several improvements.
\begin{itemize}
  \item There is a time overhead for parsing the cached profiles file when the JVM boots up. This could be lowered by finding more compact ways of storing profiles to disk or storing the cached profiles in main memory.
  \item The data structure of the cached profiles is a simple C heap array. The worst case lookup is $O(n)$ with $n$ being the number of cached method compilations. By using a more advanced tree-like data structure we could improve this to $O(log(n))$.
  \item Additionally, all method compilations get dumped and stored. The system could be extended in a way, that only the last compilation record of a method is kept in the file. On cost of additional memory overhead, this can decrease the size of the cached profile file and result in a lower parsing time.
  \item Currently, only the profiles of a single run are used. A possible improvement is to use multiple executions for gathering the cached profiles and come up with ways to merge the profiling information. More complete profiles can be achieved, which could further reduce the number of deoptimizations.
  \item In addition to merging multiple profiles we also though about the possibility to modify the cached profile. That would allow the JVM user to manually improve profiling information by using his knowledge of the method execution which might not be available to the compiler.
  \item There are several more interesting benchmarks that could be executed. For example, one could try optimizing the benchmarks by only selecting a subset of all methods to be cached. Or a more detailed investigation on different multi core systems, to get more insight which threads are limiting performance, could be executed.
\end{itemize}
